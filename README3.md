# CHAPTER3 アプリケーションアーキテクチャ
3-1 MVCとADR  
3-2 アーキテクチャへの入り口

# 3-1 MVCとADR
MVC  
　元々UI設計のための設計パターンだったが、それをサーバーサイドに適用したもので、MVC2と呼ばれている。

トランダクションスプリクトパターン  
　ビジネスロジックの一連の処理をまとめたもので、処理に関連するものを1つのクラスにまとめ、実装する最もシンプルなパターン。

以下書籍を購入する例
①「書籍を購入する」をorderメソッドで一連の動作を表す。  
②データベースに直接アクセスして書籍情報や在庫などを取得し、購入できる状態か調べ、できなければエラーを通知する。  
③購入データをデータベースに保存する。  
④購入が完了したらポイントや購入者にメールを送信する処理など。

　このように一連の処理が1つのクラスにまとまった状態だと同じような処理が増えて共通化ができなくなったり、ごった煮となったクラスで保守・運用が難しくなったり、設計の一貫性がなくなり実装内容の把握が難しくなる。  
処理を簡単に記述できるLaravelだからこそ容易にこのような事態を招くことになるため、開発に都合がいいかではなくビジネスロジックをどう解決するかを意識する必要がある。  
この問題はレイヤ化による責務の分割を行うレイヤードアーキテクチャを取り入れると解決の糸口となる。

ドメインモデルパターン  
　ドメイン駆動設計を取り入れて、実装コードに反映していく開発スタイルから導かれるパターン。  
ドメインモデリングのスキルが必要で、トランザクションスプリクトパターンより難易度が高い。


ADR  
　MVC2と同様、MVCをサーバーサイド向けに洗練させた設計パターン。  
Action、Domain、Responderからなる。  
MVCと比較すると、モデルとドメイン、ビューとレスポンダ、コントローラとアクションがそれぞれ対応する。

アクション  
　コントローラが複数のアクションに対応するのに対し、1つのアクション、ルートにのみ対応させる。（例：UserIndexAction.php）  
コントローラは複数のメソッドに対応するが、アプリケーションが大規模になるとコントローラクラスが持つ依存関係がメソッドそれぞれで大きく変わり、あるメソッドのみ利用するクラスが増えることになる。

例）  
同一コントローラ内に、indexメソッドとstoreメソッドがあった時、storeクラスに依存するものとしてコンストラクタにServiceクラスを追加したとき、indexメソッドでは関係ない処理が増えてしまう。

アクション使い方(UserIndexActionクラス)
```
<?php
// 省略

final class UserIndexAction extends Controller
{
    private $domain;
    private $userResponder;

    public function __construct(
        UserService $userService,
        UserResponder $userResponder
    ) {
        $this->domain = $userService;
        $this->responder = $userResponder;
    }

    public function __invoke(Request $request): Response
    {
        return $this->userResponder->response(
            $this->domain->retrieveUser($request->get('id'))
        );
    }
}
```
①コントローラで実装するものをアクションクラスとして独立させ、レスポンダを依存関係として加える。別のメソッドの不要な依存関係は実装する必要がない。  
②レスポンダにドメインの処理結果を渡し、どのようなレスポンスを返却するかレスポンダに移譲している。  

ルーター
```
Route::get('users', App\Http\Actions\UserIndexAction::class);
```

ドメイン  
　モデルと大きな違いはない。

レスポンダ  
　MVCのビューはコントローラを介して描画させたい内容のみを渡し、コンテンツ以外のHTTPステータスコードなどはコントローラで設定する必要がある。  
そのロジックをコントローラ・アクションから切り離したのがレスポンダになる。  
HTTPレスポンスを構築する処理を担う。

　以下例では、ドメインから返却された値を利用し、どのようなレスポンスを返却するかを実装している。
```
// 省略
class BookResponder
{
    protected $response;
    protected $view;

    public function __construct(Response $response, ViewFactory $view)
    {
        $this->response = $response;
        $this->view = $view;
    }

    public function response(UserModel $user): Response
    {
        if (!$user->id) {
            $this->response->setStatucCode(Response::HTTP_NOT_FOUND);
        }
        $this->response->setContent(
            $this->view->make('user.index', ['user' => $user])
        );
        return $this->response;
    }
}
```

　MVCよりもクラスが増えることがデメリットではなく、整理された小さな機能の集まりで、責務が明確化していると言える。  
各クラスの処理が小さくなることで、仕様変更やテストの容易さが向上する。

# 3-2 アーキテクチャへの入り口
　データソースの操作とビジネスロジックは切っても切り離せない関係だが、複雑化しやすく想定外の進化を遂げることもある。  
そのためアーキテクチャ設計が重要になる。

　Laravelフレームワークは数々の機能が用意されているが、すべてのビジネル要求を完全に実現するわけではない。  
フレームワークを骨組みに個別に的確な構造化や設計技法が必要となる。  
コントローラやミドルウェアにEloquent処理を大量に書いてしまったり、Eloquentモデルクラスにキャッシュやセッションアドを扱う処理があると、複雑化され拡張が難しくなる。  
これらはフレームワークが悪いのではなく、適切な設計パターンを定めていないことにある。


レイヤードアーキテクチャ
　一つのクラスにいろんな処理が書き込まれるのではなく、それぞれの関心ごとを分離し分離した要素に対して実装を行う必要がある。  
レイヤードアーキテクチャは、複雑になりやすい実装をいくつかのレイヤに分割して設計する手法となる。

　コントローラやモデルの肥大化を防ぐためには、いくつかの層に分割することで解決できる。  
アプリケーション開発で最も注力すべきビジネスロジックの複雑化を防ぎ、ビジネスロジックを担当する層から様々な依存を排除して抽象化することが大切。


　ビジネスロジックとEloquentモデル、コントローラが強く結合することが多く、これをサービスクラス、リポジトリクラスとして分離する。  
ビジネスロジックはサービスクラスが担当、Eloquentモデルはリポジトリクラスが担当する。

　アプリケーションの規模拡大に伴い、データベースの変更を伴うこともある。  
そのため、リポジトリクラスをインターフェースを定義し実装することで、eloquentモデル以外の選択肢が有効になる。NoSQLなど。  
その場合、eloquentモデルが返すコレクション型ではなく、PHPで用意している型を用いる方が良い。

　複雑化するアプリケーションへの対応はレイヤ化だけでは不十分であり、ドメイン設計という選択肢もある。


# 不明点
- [x] ドメイン設計とはそもそも何か

# 調べたこと

