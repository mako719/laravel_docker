# CHAPTER7 イベントとキューによる処理の分離
7-1　イベント  
7-2　キュー  
7-3　イベントとキューによるCQRS

# 7-1 イベント
イベントとは  
　プログラムから何らかの操作があった際などに処理を実行する仕組み。  
イベントを発行することでイベントクラスを呼び出すことができ、イベント自体に処理はなく、イベントでは主に値を扱いその値をリスナーへと受け渡す。  
サービスプロバイダにイベントクラスとリスナークラスが対応するように登録する。

リスナーとは  
　発生したイベントを受け取りイベントの発生を監視しているのがリスナー。  
リスナーで実際に処理が行われ、リスナーはイベント毎に作成し登録する必要がある。


# 7-2 キュー
　要件次第では処理に時間を要する機能が必要となり、処理終了までユーザーを待機させる仕様は離脱につながる。  
キューは、コマンドラインまたは常駐プログラム（Daemon）で、時間がかかる処理をリクエスト・レスポンスの流れとは異なるタスクとして実行できる。  
　ただし、処理結果をレスポンスに利用することはできない。

キューの基本  
　イベントとの違いは、ジョブとして通常のランタイムと異なる処理を提供する。  
キューで実行される処理は主にジョブやタスクと呼ばれ、登録された順番（First In First Out）で実行する。  
格納されたジョブを削除する機能はないため、DBから直接削除する必要がある。

　PDF作成やレポート作成などの機能は、ビジネスロジックの実装として複雑になりがちだが、キューを使った非同期処理としてクラスを分割できる。  
そのため、クラス1つ1つの役割が明確になるため、保守性や拡張性の維持が容易になる。

非同期実行ドライバの準備  
　Queueはデータベースをはじめ、Beanstalkd、Amazon Simple QueueService、Redisを用意している。

・Redis  
　高速なパフォーマンスと様々なデータ構造を扱えるのが特徴。  
環境構築も容易であることから導入事例も多い。  
・Sync  
　非同期ではなく同期実行となる。  
このドライバは主にテストやデバッグで利用して、商用環境では利用しない。

ヘルパ関数  
・非同期　dispatch()  
・同期　dispatch_sync()

ジョブの実装  
1. make:jobコマンドを実行し、hundleメソッドに処理を記述する。
2. コントローラーなどからDispatcherインタフェース、Busファサード、dispatchヘルパ関数などで実行を指示する。
3. .envのQUEUE_CONNECTIONをsyncにすると同期、redisにすると非同期になる。
4. php artisan queue:workでジョブを実行する。

Supervisorによる常駐プログラムパターン  
　queue:workコマンドはコンソールから接続を切ると処理が停止する。  
Supervisorを使うことで、キューを常駐プログラムとして設定できる（商用環境でも利用される）。
Unix環境で動作するため、Windowsで動かすことはできない。Ubuntu、CentOS、macOS環境を利用する。

Supervisorの設定  
　環境によって異なるが、/etc/supervisor/conf.d、/etc/supervisor/supervisord.d配下に設定ファイルを設置する。  
queue:workを常駐プログラムとして動作させる設定をする。  
Jobごとに設定ファイルを作成する（例：pdf-generator.conf）。  
　設定ファイル記述後に、supervisorctlを再起動すると対象プロセスが管理対象に含まれる。  
　失敗したプロセスはリトライ回数上限になるとFATAL状態になる。また、異常終了となることもある。  
そのため、SupervisorのプラグインパッケージのSuperlanceを利用することで、そのような状態になったときにメールで通知することができる。

手軽な分散処理パターン  
　大規模なアプリケーションでは多数の処理がキューで実行されるので、メール送信やPDFファイル作成などキュー内で順番待ちの状態が発生する。  
デフォルトではQueue名[default]に格納されるため、ジョブに合わせてQueueドライバに振り分けて負荷を分散する。  
高速な処理が必要な場合は、RedisやSQS、待機しても構わないものはデータベースを利用するなど。

```
// デフォルトのキュート異なる格納先を指定
dispatch($geneerator)->onQueue('pdf.generator');

// 実行時間を1時間遅らせる
dispatch(new SendRegistMail($event->user->email))
    ->onQueue('mail')
    ->delay(now()->addHour(1));
```
　それぞれ別のキューとして実行されるため、--queueオプションを指定する。
```
php artisan queue:work --queue pdf.generator
php artisan queue:work --queue mail
```

　キューの処理速度はサーバのスペックや設定にも大きく影響する。  
時間がかかる処理や大量のメモリやCPUを占める処理を実行されるとサーバ自体のリソース不足を引き起こし、パフォーマンスに影響が出てくる。  
キューの処理とWebアプリケーションのサーバの分割、ハードウェア環境の補強を検討する。

# 7-3 イベントとキューによるCQRS
　アプリケーションが大規模になるにつれ、レコード数やデータベースクエリの複雑化に伴う応答速度の低下が露呈することがある。  
LIKE検索などのパフォーマンス低下に加え、コードの複雑化が見られる。  
CQRS（コマンドクエリ責務分離）とは、書き込み（コマンド）と読み込み（クエリ）を別々に取り扱うべきと考える設計方法で、切り離すことでここの処理を小さくシンプルにすることを実現する。  
コマンドには確実なデータ書き込みと整合性の担保が可能なRDBMSを採用し、クエリを担当するデータベースにはパフォーマウンスなどを考慮してElasticsearchをはじめとする全文検索エンジンを選択することが多い。

　今回は口コミに類するレビュー投稿、取得機能APIをCQRSを採用して実装する。  
口コミ投稿APIではMySQLへレコード挿入後イベントを発生される。このイベントに対するリスナーは、Redisを利用したキューを介してElasticsearchのインデックスに非同期でドキュメントを挿入する。  
　また、口コミ取得APIにはフリーワード検索を実装し、口コミを一覧で取得できる機能を用意する。

　実際は規模に応じて構成を変更する。  
例えば、コマンド発行時にMySQLの書き込み、キューを使ってイベント通知といった流れにすると、トランザクションが多段になってしまうため、実際はキューでイベントだけを発行し、それぞれのデータベースに書き込み、加工処理を行う。  
整合性やスケーラビリティを重視するアプリケーションでは、RabbitMQやApache Kalfaなどのメッセージングミドルウェアを選択する。

　実際のコードは実装を参照。


# 不明点
- [ ] キュー　実装中のエラーについて
- [ ] CHAPTER7-3 実装のAppServiceProviderにバインドを定義する理由
- [ ] ListenerクラスでimplementsしているShouldQueueクラスとは
- [ ] CHAPTER7-3 indexメソッドのエラー


# 調べたこと
キュー　実装中のエラーについて  
ローカル環境エラーについて
　wkhtmltopdefはコマンド打ったら動作するからインストールはできている？  
Pdfクラスがないので、インストールがうまくいってない？  
キュー自体は参考書レベルの理解はできた。  
解決できなそうなので、先に進める

CHAPTER7-3 実装のAppServiceProviderにバインドを定義する理由  
　インターフェースをバインドして、コンストラクタインジェクションで解決する時に実装クラスをインスタンス化するため？
